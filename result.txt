enhance_gan_train.py:19:from model.gan_model import GANModel, GANLoss
enhance_gan_train.py:57:    loss_report = visualizer.add_plot_report(['train/loss', 'val/loss', 'train/gan_loss', 'train/enhance_loss','train/loss_D'], 'loss.png')
enhance_gan_train.py:95:    gan_model = GANModel.load_model(model_path, 'gan_state_dict', opt) 
enhance_gan_train.py:96:    if opt.enhance_opt_type == 'gan_fft':
enhance_gan_train.py:98:    elif opt.enhance_opt_type == 'gan_fbank':
enhance_gan_train.py:105:    gan_parameters = filter(lambda p: p.requires_grad, gan_model.parameters())   
enhance_gan_train.py:108:        gan_optimizer = torch.optim.Adadelta(gan_parameters, rho=0.95, eps=eps)
enhance_gan_train.py:111:        gan_optimizer = torch.optim.Adam(gan_parameters, lr=lr, betas=(opt.beta1, 0.999))
enhance_gan_train.py:112:    criterionGAN = GANLoss(use_lsgan=not opt.no_lsgan).to(device)
enhance_gan_train.py:118:    gan_model.train()              	                    
enhance_gan_train.py:128:            set_requires_grad([gan_model], False)
enhance_gan_train.py:129:            gan_loss = criterionGAN(gan_model(enhance_feat), True)
enhance_gan_train.py:131:            loss = enhance_loss + opt.gan_loss_lambda * gan_loss
enhance_gan_train.py:140:            set_requires_grad([gan_model], True)   
enhance_gan_train.py:141:            gan_optimizer.zero_grad()
enhance_gan_train.py:142:            loss_D_real = criterionGAN(gan_model(clean_feat.detach()), True)
enhance_gan_train.py:143:            loss_D_fake = criterionGAN(gan_model(enhance_feat.detach()), False)
enhance_gan_train.py:146:            grad_norm = torch.nn.utils.clip_grad_norm_(gan_model.parameters(), opt.grad_clip)
enhance_gan_train.py:150:                gan_optimizer.step()
enhance_gan_train.py:153:            errors = {'train/loss': loss.item(), 'train/gan_loss': gan_loss.item(), 
enhance_gan_train.py:159:                         'gan_state_dict': gan_model.state_dict(), 
enhance_gan_train.py:162:                if opt.enhance_opt_type == 'gan_fft':
enhance_gan_train.py:164:                elif opt.enhance_opt_type == 'gan_fbank':    
enhance_gan_train.py:172:                gan_model.eval()
enhance_gan_train.py:203:                gan_model.train() 
enhance_gan_train.py:220:                         'gan_state_dict': gan_model.state_dict(), 
enhance_gan_train.py:223:                if opt.enhance_opt_type == 'gan_fft':
enhance_gan_train.py:225:                elif opt.enhance_opt_type == 'gan_fbank':    
joint_train.py:20:from model.gan_model import GANModel, GANLoss, CORAL
joint_train.py:123:        gan_model = GANModel.load_model(joint_model_path, 'gan_state_dict', opt) 
joint_train.py:130:        gan_parameters = filter(lambda p: p.requires_grad, gan_model.parameters())   
joint_train.py:135:            gan_optimizer = torch.optim.Adadelta(gan_parameters, rho=0.95, eps=eps)
joint_train.py:140:            gan_optimizer = torch.optim.Adam(gan_parameters, lr=lr, betas=(opt.beta1, 0.999))
joint_train.py:142:        criterionGAN = GANLoss(use_lsgan=not opt.no_lsgan).to(device)
joint_train.py:176:                set_requires_grad([gan_model], False)
joint_train.py:181:                gan_loss = opt.gan_loss_lambda * criterionGAN(gan_model(fake_AB, enhance_cmvn), True)
joint_train.py:182:                loss += gan_loss
joint_train.py:196:                set_requires_grad([gan_model], True)   
joint_train.py:197:                gan_optimizer.zero_grad()
joint_train.py:204:                loss_D_real = criterionGAN(gan_model(real_AB.detach(), enhance_cmvn), True)
joint_train.py:205:                loss_D_fake = criterionGAN(gan_model(fake_AB.detach(), enhance_cmvn), False)
joint_train.py:208:                grad_norm = torch.nn.utils.clip_grad_norm_(gan_model.parameters(), opt.grad_clip)
joint_train.py:212:                    gan_optimizer.step()
joint_train.py:220:                errors['train/gan_loss'] = opt.gan_loss_lambda * gan_loss.item()  
joint_train.py:233:                    state['gan_state_dict'] = gan_model.state_dict()
joint_train.py:258:                        set_requires_grad([gan_model], False)
joint_train.py:263:                        gan_loss = criterionGAN(gan_model(fake_AB, enhance_cmvn), True)
joint_train.py:264:                        enhance_loss += opt.gan_loss_lambda * gan_loss
joint_train.py:275:                        errors['val/gan_loss'] = opt.gan_loss_lambda * gan_loss.item()  
joint_train.py:326:                    state['gan_state_dict'] = gan_model.state_dict()
